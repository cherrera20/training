\documentclass[pdftex,hyperref]{beamer}

\usepackage[spanish]{babel}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}

\usepackage{graphicx}
\usepackage{url}
\usepackage{hyperref}
\usepackage{amssymb}
\usepackage{colortbl}
\usepackage{listings}
\usepackage{fancyvrb}
\usepackage{multirow}
\usepackage{hyperref}
\usepackage{bibentry}
\usepackage{listings}
\usepackage{tabularx}

\definecolor{linkblue}{RGB}{49,57,174}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstdefinelanguage{scala}{
  morekeywords={abstract,annotation,case,catch,class,def,%
    do,else,extends,false,final,finally,%
    for,if,implicit,import,match,mixin,%
    new,null,object,override,package,%
    private,protected,requires,return,sealed,%
    super,this,throw,trait,true,try,%
    type,val,var,while,with,yield,
    macro},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[n]{/*}{*/},
  morestring=[b]",
  morestring=[b]',
  morestring=[b]"""
}
\lstset{frame=tb,
  language=scala,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  frame=single,
  breaklines=true,
  breakatwhitespace=true
  tabsize=3
}

% Configuracion del documento PDF.
\hypersetup{
  pdfcreator=Jesús López González,
  backref%,
  %%pdfpagemode=FullScreen
}

% Configuracion pagina principal

\title{\textbf{Programación Funcional en Scala}}
\subtitle{\textbf{ -- Tema 2 -- \\ Introducción a la Programación Funcional }}
\author[Jesús López González]{Jesús López González\\jesus.lopez@hablapps.com}
\institute[@jeslg]{Programación Funcional en Scala\\ Habla Computing}
\date{Cursos ETSII-URJC 2015}

% Eleccion estilo de la presentacion

\mode<presentation>
{
 \usetheme{Madrid}
 \setbeamercovered{transparent}
}

\def\newblock{\hskip .11em plus .33em minus .07em}

% Configuracion del logo de la imagen

\subject{Talks}

\pgfdeclareimage[height=0.5cm]{university-logo}{images/logoURJC}
\logo{\pgfuseimage{university-logo}}

\setcounter{tocdepth}{1}

%NOANIMACION
\beamerdefaultoverlayspecification{}

% Volver a recordar tabla de contenidos en subsecciones

\AtBeginSection[]
{
  \begin{frame}<beamer>{Índice}
    \tableofcontents[currentsection]
  \end{frame}
}

\nobibliography* 

\begin{document}

\begin{frame}
  \titlepage
\end{frame}

\section{¿Qué es la Programación Funcional?}

\begin{frame}[fragile]
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{block}{Efectos de Lado}
    Se dice que una función tiene efectos de lado si, además de
    devolver un valor, modifica algún estado o interactúa visiblemente
    con el mundo externo.
  \end{block}

  \begin{block}{Ejemplos}
    \begin{itemize}
    \item Modificar una variable global
    \item Invocar un \emph{setter}
    \item Lanzar una excepción
    \item Imprimir una traza por la consola
    \item Actualizar un dato en una BBDD
    \item Invocar un servicio web externo
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{block}{Paradigma Funcional y Pureza}
    La programación funcional se basa en una única premisa: programar
    con \emph{funciones puras}. Una función pura es aquella que no
    tiene efectos de lado y que para una misma entrada siempre
    devolverá la misma salida (mapeo de valores).
  \end{block}

  \begin{lstlisting}[language=scala, caption=Ejemplo de función pura]
def add(a: Int, b: Int): Int = a + b
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{block}{Transparencia Referencial y Modelo de Sustitución} 
    Se dice que una expresión es \emph{referentially transparent} si
    tras reemplazarla por el valor que devuelve, no se aprecia ningún
    cambio en el comportamiento del programa. Esta cualidad activa un
    nuevo modo de evaluar nuestros programas: \emph{el modelo de
      sustitución}. Y es que cuando contamos con la transparencia
    referencial podemos razonar sobre nuestros programas como si se
    tratasen de expresiones algebraicas.
  \end{block}

  \begin{lstlisting}[language=scala, caption=Aplicando el modelo de
      sustitución sobre una expresión]
def add(a: Int, b: Int): Int = a + b

add(add(1, 2), add(add(4, 5), 6))
add(3, add(add(4, 5), 6))
add(3, add(9, 6))
add(3, 15)
18
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{lstlisting}[language=scala, caption=¿Es una función pura?]
var lastAdd: Int = 0

def add2(a: Int, b: Int): Int = {
  val res = a + b
  lastAdd = res
  res
}

// Puedes apoyarte en el siguiente programa...

add2(1, 2)
doSomething(lastAdd)
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{lstlisting}[language=scala, caption=¿Y esta función?]
def add3(a: Int, b: Int): Int = {
  println(s"Adding $a and $b")
  a + b
}
  \end{lstlisting}

  \begin{lstlisting}[language=scala, caption=¿Y ésta otra?]
def add4(a: Int, b: Int): Int = {
  var res = a + b
  res = res - 1
  res = res + 1
  res
}
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{block}{¿Por qué preocuparnos por el Paradigma Funcional?}
    
    % Hablar sobre la historia de la programación funcional

    \begin{itemize}
      \item Eficiencia / Escalabilidad (multi-cores, Big Data)
      \item Modularidad (reusabilidad, composición\ldots)
      \item Testability (property-based testing)
      \item Comprensibilidad (estructura, funcionamiento,
        depuración\ldots)
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{¿Qué es la Programación Funcional?}

  \begin{block}{¿Y por qué preocuparnos por Scala?}
    \begin{itemize}
      \item Multiparadigma e Impuro (\emph{Scala as a better Java})
      \item Lenguaje JVM estáticamente tipado
      \item Más que un lenguaje, un ecosistema (Play, Akka,
        Spark\ldots)
    \end{itemize}
  \end{block}

  %% Explicación del tipo Unit (tuplas) ¿Realmente podemos ser puros?
  %% Impureza de Scala

  \begin{lstlisting}[language=scala, caption=Hola Mundo en Scala]
object HolaMundo {
  def main(args: Array[String]): Unit = {
    println("¡Hola Mundo!")
  }
}
  \end{lstlisting}
\end{frame}

\section{Funciones en Scala}

\begin{frame}
  \frametitle{Funciones en Scala}

  \begin{center}
    \includegraphics[width=0.5\linewidth]{images/functions-everywhere.jpg}
  \end{center}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \begin{block}{Definición de Función}
    Una \textbf{función} es un dispositivo computacional componible
    que permite exclusivamente transformar valores de entrada en
    valores de salida.
  \end{block}

  \begin{lstlisting}[language=scala, caption=Nuestra ya conocida
      función add]
def add(a: Int, b: Int): Int = a + b
  \end{lstlisting}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \begin{block}{Funciones como ciudadanos de primera clase}
    En Scala, es posible tratar una función como si de un valor se
    tratase. Por tanto, una función puede ser utilizada para definir
    el valor de una variable o para pasarse como parámetro a otras
    funciones (ver diapositiva \ref{lst:first-class-repl}).
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \label{lst:first-class-repl}
  \begin{lstlisting}[language=scala, caption=Funciones como ciudadanos de
      primera clase]
scala> def add(a: Int, b: Int): Int = a + b
add: (a: Int, b: Int)Int

scala> val addV1: (Int, Int) => Int = add
addV1: (Int, Int) => Int = <function2>

scala> addV1(1, 2)
res0: Int = 3

scala> val addV2 = add _
addV2: (Int, Int) => Int = <function2>

scala> addV2(1, 2)
res1: Int = 3
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \begin{block}{Funciones de orden superior}
    Una función de orden superior es aquella que cumple al menos una
    de las siguientes condiciones:
    \begin{itemize}
    \item Toma al menos una función como entrada
    \item Devuelve una función como salida
    \end{itemize}
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \label{lst:higher-order-repl}
  \begin{lstlisting}[language=scala, caption=Funciones de orden
      superior]
scala> def add(a: Int, b: Int): Int = a + b
add: (a: Int, b: Int)Int

scala> def mul(a: Int, b: Int): Int = a * b
mul: (a: Int, b: Int)Int

scala> def reduce(pair: (Int, Int), f: (Int, Int) => Int): Int = 
     |   f(pair._1, pair._2)
reduce: (pair: (Int, Int), f: (Int, Int) => Int)Int

scala> reduce((3, 2), add)
res0: Int = 5

scala> reduce((3, 2), mul)
res1: Int = 6
  \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \begin{block}{Funciones anónimas o expresiones lambda}
    En Scala, el trabajo con funciones es tan frecuente que surge la
    necesidad de contar con funciones anónimas que puedan definirse
    \emph{inline} con una sintaxis ligera. Estas funciones también son
    conocidas como expresiones lambda.
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \label{lst:lambda-repl}
  \begin{lstlisting}[language=scala, caption=Uso de funciones anónimas]
scala> val add: (Int, Int) => Int = (a: Int, b: Int) => a + b
add: (Int, Int) => Int = <function2>

scala> val add2: (Int, Int) => Int = (a, b) => a + b
add2: (Int, Int) => Int = <function2>

scala> val add3: (Int, Int) => Int = _ + _
add3: (Int, Int) => Int = <function2>

scala> def reduce(pair: (Int, Int), f: (Int, Int) => Int): Int = f(pair._1, pair._2)
reduce: (pair: (Int, Int), f: (Int, Int) => Int)Int

scala> reduce((5, 3), (a, b) => a * b)
res0: Int = 15
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Funciones en Scala}

  \begin{block}{Variadic Function}
    Hay funciones que pueden invocarse con un número variable de
    argumentos. Tales funciones son conocidas como \emph{variadic
      function} y pueden llegar a resultar muy útiles en diversos
    contextos (ver diapositiva \ref{lst:variadic-repl}).
  \end{block}

\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  %% Incluso el constructor List es una función variadic

  \label{lst:variadic-repl}
  \begin{lstlisting}[language=scala, caption=Declaración y uso de una
      función variadic]
scala> def add(xs: Int*) = xs.fold(0)(_ + _)
add: (xs: Int*)Int

scala> add(1, 2)
res0: Int = 3

scala> add(1, 2, 3, 4, 5)
res1: Int = 15

scala> val l = List(1, 2, 3, 4, 5)
l: List[Int] = List(1, 2, 3, 4, 5)

scala> add(l:_*)
res3: Int = 15
  \end{lstlisting}
\end{frame}

\begin{frame}
  \frametitle{Funciones en Scala}

  \begin{block}{Función con múltiples listas de argumentos}
    Hasta ahora todas las funciones que hemos visto tienen una única
    lista de argumentos de entrada. Scala nos permite que podamos
    desplegar varias listas. Esto, que a priori puede resultar de poca
    utilidad, tiene aplicación en ciertas situaciones:
    \begin{itemize}
    \item En el trabajo con implícitos (que veremos en el T3)
    \item Para ayudar al compilador con la inferencia de tipos
    \item Si queremos utilizar la técnica de \emph{currifying}, que
      veremos en el siguiente apartado.
    \end{itemize}
  \end{block}
\end{frame}

\begin{frame}[fragile]
  \frametitle{Funciones en Scala}

  \label{lst:multiple-args-repl}
  \begin{lstlisting}[language=scala, caption=Función con múltiples
      listas de argumentos]
scala> def add(a: Int)(b: Int)(c: Int, d: Int): Int = 
     |   a + b + c + d
add: (a: Int)(b: Int)(c: Int, d: Int)Int

scala> add(1)(2)(3, 4)
res4: Int = 10
  \end{lstlisting}
\end{frame}

%% Currificación

%% Composición de Funciones

%% Funciones Polimórficas

%% Documentación de funciones (Scala List vs Java ArrayList)

\section{Tipos algebraicos de datos (ADTs)}

%% objects y case classes (apply, unapply...)

%% pattern matching

%% inmutabilidad y data sharing

%% Ejemplos: Option y List

\section{Ejemplo: Plegando Listas}

%% Funciones recursivas

%% Implementando fold, foldLeft y foldRight

\section{Takeaways}

\end{document} 
